/* Generated by chaintool.  DO NOT EDIT */

package ccs

import (
	"errors"
	"regexp"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
	"hyperledger/ccs/api"
)

type Interfaces map[string]interface{}
type Dispatchers map[string]api.Dispatcher

type stubHandler struct {
	dispatchers Dispatchers
}

var functionspec = regexp.MustCompile("([a-zA-Z0-9.]*)/fcn/([0-9]*)")

// Initialization function, called only once
func (self *stubHandler) Init(stub shim.ChaincodeStubInterface) pb.Response {

	args := stub.GetArgs()

	if len(args) != 2 {
		return shim.Error("Expected exactly two arguments")
	}

	function := string(args[0])

	if function != "init" {
		return shim.Error("Function must be \"init\"")
	}

	dispatcher, ok := self.dispatchers["appinit"]
	if !ok {
		return shim.Error("Interface not found")
	}

	return dispatcher.Dispatch(stub, 1, args[1])
}

// Callback representing the invocation of a chaincode
func (self *stubHandler) Invoke(stub shim.ChaincodeStubInterface) pb.Response {

	args := stub.GetArgs()

	var params []byte

	if len(args) > 1 {
		params = args[1]
	}

	dispatcher, index, err := self.decodeFunction(string(args[0]))
	if err != nil {
		return shim.Error(err.Error())
	}

	return dispatcher.Dispatch(stub, index, params)
}

func (self *stubHandler) decodeFunction(function string) (api.Dispatcher, int, error) {

	spec := functionspec.FindAllStringSubmatch(function, -1)
	if spec == nil {
		return nil, 0, errors.New("Could not parse function name")
	}

	dispatcher, ok := self.dispatchers[spec[0][1]]
	if !ok {
		return nil, 0, errors.New("Interface not found")
	}

	index, err := strconv.Atoi(spec[0][2])
	if err != nil {
		return nil, 0, errors.New("Could not convert function index")
	}

	return dispatcher, index, nil
}

func (self *stubHandler) addDispatcher(name string, intf interface{}) error {

	dispatcher, err := api.Create(name, intf)
	if err != nil {
		return err
	}

	self.dispatchers[name] = dispatcher
	return nil
}

func Start(interfaces Interfaces) error {

	metadata := &ChaincodeMetaData{}
	handler := &stubHandler{dispatchers: make(Dispatchers)}

	// Install our metadata impl first so that we give the user a chance to subclass and override
	if err := handler.addDispatcher("org.hyperledger.chaintool.meta", metadata); err != nil {
		return err
	}

	// Install all of the declared interfaces
	for name, intf := range interfaces {
		if err := handler.addDispatcher(name, intf); err != nil {
			return err
		}
	}

	err := shim.Start(handler)
	if err != nil {
		return err
	}

	return nil
}
